# 多星卫星执行器系统 - 开发文档

## 1. 项目概述（面向多星）

**多星卫星执行器**是一个基于行为树的任务执行系统：它接收来自上层规划器/调度器的多星调度结果，并在各卫星上并行驱动任务执行，最终完成姿态控制、载荷操作、通信等动作，并持续回传状态。

**核心理念**
- **输入**：多星调度结果（包含各卫星的任务/行为树与约束信息）
- **处理**：解析 → 分发/调度 → 约束检查 → 执行 → 状态/变量更新 → 状态同步
- **输出**：设备控制动作 + 可追溯的状态反馈（单星内 + 多星间）

## 2. 总体架构（多星优先）

多星系统由“协调层 + 单星执行器层”组成：协调层负责解析调度结果、任务分发与状态同步；单星执行器层负责将行为树落地为具体命令并执行。

```
规划器/调度器输出（多星调度结果）
    ↓
[A] 多星协调层
    ├── [7] 多星协调器：解析调度结果、分发任务、聚合状态
    └── [8] 星间通信管理器：状态同步、消息传递
    ↓
各卫星单星执行器（并行）
    ├── 卫星 S1：单星执行器组件 [1-6]
    ├── 卫星 S2：单星执行器组件 [1-6]
    └── 卫星 Sn：单星执行器组件 [1-6]
```

### 2.1 单星执行器内部结构（复用但定位清晰）

单星执行器负责把“行为树”变为“可执行命令序列/图”，并在约束满足时驱动执行，产出状态与变量。

```
行为树输入（该卫星）
    ↓
[1] 行为树解析器：解析结构、节点类型与参数
    ↓
[2] 命令节点驱动器：按控制逻辑触发节点
    ↓
[3] 命令约束评估器：检查可执行性（资源/时间窗/依赖/事件）
    ↓
[4] 命令执行与系统适配器：下发到姿控/载荷/通信/计算等
    ↓
[5] 命令状态管理器：维护状态机与历史
[6] 变量状态管理器：维护全局/局部/中间产出
```

## 3. 端到端执行流程（从多星到单星）

### 3.1 多星层流程
1. 接收调度结果（可能包含：卫星列表、每星任务/行为树、时间窗、资源约束等）。
2. 多星协调器按卫星拆分任务，形成“每星执行输入”。
3. 通过星间通信分发到各卫星执行器，并订阅回传状态。
4. 汇聚各卫星执行进度/结果，对上层提供统一的状态视图。

### 3.2 单星层流程（每颗卫星相同）
1. 行为树解析：生成节点列表与执行依赖关系。
2. 节点驱动：按顺序/并行/条件/选择等控制逻辑推进。
3. 约束检查：
   - 若约束满足：进入执行；
   - 若约束可能在未来满足：进入等待/延迟；
   - 若不可满足：标记阻塞并上报。
4. 命令执行：调用系统适配器下发底层指令，接收反馈。
5. 状态与变量更新：落库/持久化（按需求），并向多星层同步关键状态。

## 4. 组件职责（按层次）

### 4.1 多星协调层

#### 7. 多星协调器 (Multi-Satellite Coordinator)

**作用**：多星执行入口与总控；把“多星调度结果”转换为“各卫星执行输入”，并对外提供汇总状态。

**核心职责**：
- 解析调度结果（任务拆分、分组、时序信息）。
- 面向卫星的任务分发（将每星行为树/任务输入下发）。
- 汇聚各卫星状态，形成统一的任务进度视图。

**输入/输出**：
- 输入：多星调度结果
- 输出：每星执行输入 + 汇总执行状态

#### 8. 星间通信管理器 (Inter-Satellite Communication Manager)

**作用**：提供状态同步与消息传递通道。

**核心职责**：
- 发送：任务下发、状态上报、必要的同步消息。
- 接收：各星执行状态、关键事件、错误信息。

**输入/输出**：
- 输入：消息/状态
- 输出：消息/状态

> 注：本模块偏“通信与同步能力”，不改变单星执行语义。

### 4.2 单星执行器层（每星通用）

#### 1. 行为树解析器 (Behavior Tree Parser)

**作用**：把行为树“翻译”为系统可执行的内部表示。

**功能**：
- 读取行为树文件/数据
- 识别节点类型（顺序节点、条件节点、动作节点等）
- 解析节点间的依赖关系与执行顺序
- 提取每个节点的参数和配置

**输入示例**：
```
行为树节点：
- 顺序节点: 拍照任务
  - 条件节点: 检查电量 > 50%
  - 动作节点: 调整姿态 (朝向: 目标A)
  - 动作节点: 启动相机
  - 动作节点: 拍照 (分辨率: 高清)
```

**输出**：解析后的节点列表 + 执行依赖图

#### 2. 命令节点驱动器 (Command Node Driver)

**作用**：按行为树控制逻辑推进执行（“任务调度员”）。

**功能**：
- 遍历行为树节点
- 根据节点类型决定执行策略：
  - **顺序节点**：依次执行子节点
  - **并行节点**：同时执行多个子节点
  - **条件节点**：先判断条件，再决定是否执行
  - **选择节点**：执行第一个成功的子节点
- 处理循环、重试等控制逻辑

**执行模式**：
- 深度优先遍历
- 支持条件跳转
- 支持失败重试

#### 3. 命令约束评估器 (Command Constraint Evaluator)

**作用**：执行前的“安全检查”，决定是否允许/延迟/阻塞。

**检查内容**：
1. **前置任务状态**：例如“拍照”前必须先完成“姿态调整”
2. **资源可用性**：电量是否充足、存储空间是否够用
3. **时间窗**：是否在允许的时间范围内（如只能在白天拍照）
4. **事件触发条件**：是否收到特定信号或达到特定位置

**约束类型**：
- **硬约束**：不满足则无法执行（如电量不足）
- **软约束**：不满足可警告但仍可执行

**处理逻辑**：
```
if 约束满足:
    执行命令
elif 约束可能在未来满足:
    推迟执行，进入等待队列
else:
    标记为阻塞，上报错误
```

#### 4. 命令执行与系统适配器 (Command Executor & System Adapter)

**作用**：把高层命令映射为底层设备动作（“执行层”）。

**功能**：
- 提供统一的命令接口（抽象层）
- 适配不同的底层硬件与协议
- 将高层命令转换为底层设备指令
- 接收设备反馈并上报结果

**支持的命令类型**：
- **姿态控制**：调整卫星朝向
- **载荷控制**：控制相机、传感器等
- **通信控制**：建立/断开通信链路、传输数据
- **计算任务**：启动星载计算任务

**适配器架构**：
```
统一命令接口
    ↓
姿控适配器 | 载荷适配器 | 通信适配器 | 计算适配器
    ↓
底层设备驱动
```

#### 5. 命令状态管理器 (Command State Manager)

**作用**：追踪每个命令节点的生命周期状态，支持查询与追溯。

**状态机定义**：
```
未开始 (NOT_STARTED)
    ↓
就绪 (READY) ← 前置条件满足
    ↓
执行中 (RUNNING) ← 正在执行
    ↓
成功 (SUCCESS) / 失败 (FAILED) / 阻塞 (BLOCKED)
```

**管理内容**：
- 当前状态
- 状态转换时间
- 执行日志
- 错误信息（如果失败）

**API示例**：
```cpp
// 查询命令状态
CommandStatus status = stateManager->getStatus(commandId);

// 更新状态
stateManager->updateStatus(commandId, State::RUNNING);

// 获取执行历史
auto history = stateManager->getHistory(commandId);
```

#### 6. 变量状态管理器 (Variable State Manager)

**作用**：管理执行过程中的数据（“记事本”），支撑命令间数据传递。

**变量类型**：
- **全局变量**：整个任务流程共享（如当前位置、电量）
- **局部变量**：某个子任务内使用（如单次拍照图片ID）
- **中间产出**：命令执行输出（如姿态调整后的姿态角）

**功能**：
- 变量读写
- 作用域隔离
- 数据传递（前一个命令输出作为后一个命令输入）
- 变量快照（记录某个时刻的变量状态）

**使用示例**：
```cpp
// 设置全局变量
varManager->set("current_battery", 85, Scope::GLOBAL);

// 读取变量
int battery = std::any_cast<int>(varManager->get("current_battery"));

// 命令间传递数据
std::string photoId = executePhotoCommand();
varManager->set("last_photo_id", photoId, Scope::LOCAL);
```

## 5. 数据流（单星）与同步点（多星）

### 5.1 单星数据流图（执行闭环）
```
行为树输入
    ↓
行为树解析器
    ↓
（可选）静态约束预检查
    ↓
命令节点驱动器
    ↓
动态约束评估器（包含时间约束）
    ↓
命令执行与系统适配器
    ↓
命令状态管理器 +（可选）状态持久化
    ↓
变量状态管理器
```

### 5.2 多星同步点（最小闭环）
- 任务下发：多星协调器 → 星间通信 → 各星执行器输入。
- 状态回传：各星状态管理器/关键事件 → 星间通信 → 多星协调器汇总。

## 6. 开发目标与要求（按多星落地）

### 目标1：统一命令执行框架（可扩展）
**要实现什么**：
- 标准化命令执行流程，适配多种命令类型（调姿、拍照、通信、计算等）
- 统一接口，方便扩展新命令
- 跨平台兼容（适配不同卫星平台）

**关键技术点**：
- 设计模式：策略模式（不同命令类型）、适配器模式（不同硬件）
- 接口抽象：定义 ICommand 接口
- 插件机制：动态加载新命令类型

### 目标2：命令状态管理方法（可查询、可追溯）
**要实现什么**：
- 完整记录每个命令生命周期
- 支持状态查询与追溯
- 支持并发任务状态同步
- 捕获与处理异常状态

**技术需求**：
- 状态机实现
- 线程安全/并发控制
- 状态持久化（用于故障恢复）
- 实时状态监控接口

### 目标3：命令约束状态管理方法（安全执行）
**要实现什么**：
- 动态评估命令执行条件
- 检测约束冲突（如资源争用）
- 记录约束检查日志
- 处理约束异常

**技术需求**：
- 约束表达式引擎
- 资源锁机制
- 时间窗管理
- 依赖关系图解析

### 目标4：变量状态管理方法（数据一致、可回溯）
**要实现什么**：
- 统一变量存储与访问
- 支持全局/局部作用域
- 变量版本控制（快照与回溯）
- 保证数据一致性

**技术需求**：
- 变量命名空间管理
- 数据序列化/反序列化
- 并发读写控制
- 变量变更监听机制

## 7. 开发指南（建议顺序）

1. **第一阶段：单星最小闭环**
   - [ ] 定义基础数据结构（节点、命令、状态、变量、约束结果）
   - [ ] 实现行为树解析器
   - [ ] 实现命令状态管理器（最小可用）

2. **第二阶段：单星执行引擎**
   - [ ] 实现命令节点驱动器
   - [ ] 实现变量状态管理器
   - [ ] 开发基础命令执行适配器（至少覆盖一类硬件/协议）

3. **第三阶段：约束与鲁棒性**
   - [ ] 实现命令约束评估器
   - [ ] 添加错误处理与重试机制
   - [ ] 性能优化与并发支持

4. **第四阶段：多星协同闭环**
   - [ ] 实现多星协调器（解析调度结果、分发任务、聚合状态）
   - [ ] 接入星间通信管理器（任务下发、状态回传）
   - [ ] 多星集成测试（并行执行、状态一致性）

5. **第五阶段：系统集成与测试**
   - [ ] 系统集成测试
   - [ ] 模拟器测试
   - [ ] 文档完善

```shell
e:\Actuator\
├── CMakeLists.txt
├── code/
│   ├── input/                    # 输入 JSON 文件
│   │   ├── global.json
│   │   ├── s1_planfragment.json
│   │   └── behavior_library.json
│   ├── cpp/                      # C++ 源码
│   │   ├── CMakeLists.txt
│   │   ├── core/                 # 核心类型和数据结构
│   │   ├── input/                # 输入解析
│   │   ├── parser/               # 行为树解析
│   │   ├── executor/             # 执行引擎
│   │   ├── constraint/           # 约束评估
│   │   ├── adapter/              # 系统适配器
│   │   └── main.cpp
│   └── exe/                      # 编译输出
└── 文档/
```

```shell
规划器输出（多星调度结果）
    ↓
┌─────────────────────────────────────────────┐
│ 多星协调层                                   │
│  ├── 多星协调器                              │
│  │    └── [选址模块] ← 任务分配决策          │
│  ├── [资源共享管理器] ← 管理共享资源         │
│  │    └── [信号量池] ← 控制并发访问          │
│  └── 星间通信管理器                          │
└─────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────┐
│ 多节点执行 (并行)                            │
│  Node S₁ ──┬── 单星执行器                   │
│  Node S₂ ──┤   (约束评估器中检查信号量)      │
│  Node Sn ──┘                                │
└─────────────────────────────────────────────┘
```